use std::collections::HashMap;
use std::fs::OpenOptions;
use std::io::{Error, Write};
use pyo3::{Python};
use crate::tree::game::Game;
use crate::tree::node::Decision;
use crate::tree::utility::*;

// Struct for hashing information sets
#[derive(Debug, Eq, PartialEq, Hash, Clone)]
struct SetKey(usize, String);

pub fn to_terminal(game: Game, scale: f32, is_normal: bool, py: Python) -> String{
    if is_normal {
        generate_extensive(game, scale, py)
    } else {
        generate_normal(game, scale, py)
    }
}

pub fn write_to_file(game: Game, scale: f32, file_path: &str, is_normal: bool, py: Python)
    -> Result<(), Error> {

    let latex = if is_normal {
        generate_normal(game, scale, py)
    } else {
        generate_extensive(game, scale, py)
    };

    let mut file = OpenOptions::new()
        .write(true)
        .create(true)
        .open(file_path)?;
    file.write_all(latex.as_ref())?;
    Ok(())
}

pub fn generate_normal(game:Game, scale: f32, py: Python) -> String {
    let scale = scale_to_string(scale);
    let begin = format!(r#"%%       Generated by stratpy       %%
%remember to include \usepackage{{sgame}}
\begin{{{scale}}}
\sgcolsep=20pt
\sglabelsep=20pt
\renewcommand{{\gamestretch}}{{2}}
"#);
    let title = game.title.clone();
    let (player1, player2) = (game.player[1].borrow(py).name.clone(),
                                            game.player[2].borrow(py).name.clone());
    let config = format!("\\begin{{game}}{{2}}{{2}}[{player1}][{player2}][{title}]\n");
    let p2_moves = player2_string(game.clone(), py);

    let game_matrix = if let Some(_) = game.utility {
        create_matrix_num(game.clone(), py)
    } else {
        create_matrix_var(game.clone(), py)
    };

    let end = format!("\n\\end{{game}}\n\\end{{{scale}}}");

    begin + &*config + &*p2_moves + &*game_matrix + &*end
}
pub fn generate_extensive(game: Game, scale: f32, py: Python) -> String {
    // seperate style from nodes
    // leave style detailes for users in latex
    // idealy choose level distance based on average player, or action name lengths
    let root_name = game.root.borrow(py).clone().children[0].borrow(py).clone().player.borrow(py).name.clone();
    let mut information_sets= HashMap::new().to_owned();
    let node_string = traverse_tree(game.root.borrow(py).clone(), 0, &mut information_sets, true, py);

    let begin = format!(r#"%%       Generated by stratpy       %%
% remember to include \usepackage{{tikz}}
% and \usetikzlibrary{{calc}}
\begin{{tikzpicture}}[scale={scale}]"#);

    let root = format!("\n% The Tree\n\\node(0)[solid,label=above:{{{root_name}}}]{{}}");
    let info_set = add_information_set(&mut information_sets);

    let end = format!("\n\\end{{tikzpicture}}");


    begin + style() + &*root + &*node_string + ";" + &*info_set + &*end
}

fn style() -> &'static str{
    // TODO: auto adjust distancing
    "\n
% Style for nodes
\\tikzstyle{solid}=[circle,draw,inner sep=1.2,fill=black]
\\tikzstyle{hollow}=[circle,draw,inner sep=1.2]\
\n% Spacing for every level of the tree
\\tikzstyle{level 1}=[level distance=10mm,sibling distance=35mm]
\\tikzstyle{level 2}=[level distance=15mm,sibling distance=15mm]"
}

//Traverses tree adding nodes to string and the ids of nodes sharing
// information set to the information_set Vec.

// creating a list style iterative recursive function to traverse the tree
fn traverse_tree(node: Decision, i:usize, information_set: &mut HashMap<SetKey,Vec<usize>>, is_root: bool, py: Python) -> String {
    let dir = if i == 0 {"left"} else {"right"};
    let (node_id, edge_label) = (node.id, node.name);
    let (node_type, label) = match node.utility {
        Utility::Numeral(x) => {
            let utility = format!("({}, {})", x[0], x[1]);
            ("hollow", format!("label=below:{{${utility}$}}"))
        },
        Utility::Variable(x) => {
            let utility = format!("({}, {})", x[0].name, x[1].name);
            ("hollow", format!("label=below:{{${utility}$}}"))
        }
        _ => {
            if let Some(_) = node.information_set {
                if let Some(name) = node.label {
                    ("solid", format!("label=above {dir}:{{{name}}}"))
                } else {
                    ("solid", format!(""))
                }
            } else {
                let player_name = node.children[0].borrow(py).player.borrow(py).name.clone();
                ("solid", format!("label=above {dir}:{{{player_name}}}"))
            }

        }
    };
    // if the node is part of an information set, push that value to a hashmap, creating a vec,
    // if it doesn't already exist
    if let Some(set_id) = node.information_set {
        information_set.entry(
            SetKey(set_id, node.children[0].borrow(py).player.borrow(py).name.clone()))
            .or_insert(Vec::new()).push(node.id);
    }
    let mut child_s = String::new();
    for (i, child) in node.children.iter().enumerate(){
        child_s.push_str(&*traverse_tree(child.borrow(py).clone(), i, information_set, false, py))
    }
    if is_root {
        child_s
    } else {
        let node_s = format!(r#"child{{node({node_id})[{node_type}, {label}]{{}}
    {child_s}edge from parent node[{dir}]{{${edge_label}$}}}}"#);
        node_s
    }
}

// Add's information set to the exported latex with default style
fn add_information_set(information_set: &mut HashMap<SetKey,Vec<usize>>) -> String {
    if information_set.is_empty(){ return "".to_string() }
    let mut set_string = String::from("% information set\n");
    for key in information_set.keys() {
        let (_id, name) = (key.0, key.1.clone());
        if let Some(value) = information_set.get(key){
            let (node1, node2) = (value[0], value[1]);
            set_string.push_str(&*format!("\\draw[dashed,rounded corners=10]($({node1}) \
            + (-.1,.125)$)rectangle($({node2}) +(.1,-.125)$);\n\
            \\node at ($({node1})!.5!({node2})$) {{{name}}};"))
        }

    }
    set_string
}

fn player2_string(game: Game, py: Python) -> String {
    let mut actions_str = String::new();
    for action in game.player[2].borrow(py).actions.clone() {
        actions_str.push_str(&*format!("& ${action}$"));
    }
    actions_str + "\\\\\n"
}

fn create_matrix_var(game: Game, py: Python) -> String {
    let mut matrix_str = String::new();
    let utility_matrix = game.variable.unwrap();
    let actions = game.player[1].borrow(py).actions.clone();
    for (i, list) in utility_matrix.iter().enumerate() {
        let action = actions[i].clone();
        matrix_str.push_str(&*format!("${action}$ "));
        for action in list{
            let utility = format!("& ${}$, ${}$ ", action[0].name, action[1].name);
            matrix_str.push_str(&*utility);
        }
        matrix_str.push_str("\\\\\n")
    }

    matrix_str
}

fn create_matrix_num(game: Game, py: Python) -> String {
    let mut matrix_str = String::new();
    let utility_matrix = game.utility.unwrap();
    let actions = game.player[1].borrow(py).actions.clone();
    for (i, list) in utility_matrix.iter().enumerate() {
        let action = actions[i].clone();
        matrix_str.push_str(&*format!("${action}$ "));
        for action in list{
            let utility = format!("& ${}$, ${}$ ", action[0], action[1]);
            matrix_str.push_str(&*utility);
        }
        matrix_str.push_str("\\\\\n")
    }

    matrix_str
}

fn scale_to_string(value: f32) -> String {
    match value {
        x if x >= 0.0 && x <= 0.5 => "tiny".to_string(),
        x if x > 0.5 && x <= 1.0 => "scriptsize".to_string(),
        x if x > 1.0 && x <= 1.5 => "footnotesize".to_string(),
        x if x > 1.5 && x <= 2.0 => "small".to_string(),
        x if x > 2.0 && x <= 2.5 => "normalsize".to_string(),
        x if x > 2.5 && x <= 3.0 => "large".to_string(),
        x if x > 3.0 && x <= 3.5 => "Large".to_string(),
        x if x > 3.5 && x <= 4.0 => "LARGE".to_string(),
        x if x > 4.0 && x <= 4.5 => "huge".to_string(),
        _ => "Huge".to_string(),
    }
}


#[cfg(test)]
mod tests {
    //use super::*;
    #[test]
    fn test_latex_string() {
        let vec = vec![vec![1, 2], vec![3, 4]];
        println!("{}", vec[1][1])
    }

}

