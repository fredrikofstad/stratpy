use std::collections::HashMap;
use std::fs::OpenOptions;
use std::io::{Error, Write};
use pyo3::{Python};
use crate::tree::game::Game;
use crate::tree::node::Decision;
use crate::tree::utility::*;

// Struct for hashing information sets
#[derive(Debug, Eq, PartialEq, Hash, Clone)]
struct SetKey(usize, String);

pub fn to_terminal(game: Game, scale: f32, is_normal: bool, py: Python) -> String{
    if is_normal {
        generate_extensive(game, scale, py)
    } else {
        generate_normal(game, scale, py)
    }
}

pub fn write_to_file(game: Game, scale: f32, file_path: &str, is_normal: bool, py: Python)
    -> Result<(), Error> {

    let latex = if is_normal {
        generate_normal(game, scale, py)
    } else {
        generate_extensive(game, scale, py)
    };

    let mut file = OpenOptions::new()
        .write(true)
        .create(true)
        .open(file_path)?;
    file.write_all(latex.as_ref())?;
    Ok(())
}

pub fn generate_normal(game:Game, scale: f32, py: Python) -> String {
    let scale = scale_to_string(scale);
    let begin = format!(r#"%%       Generated by stratpy       %%
%remember to include \usepackage{{sgame}}
\begin{{{scale}}}[h]
\sgcolsep=20pt
\sglabelsep=20pt
\renewcommand{{\gamestretch}}{{2}}
"#);
    if let Some(matrix) = game.variable {
        // generate variable matrix
    } else if let Some(matrix) = game.utility{
        // generate utility matrix
    }



    let end = format!("\n\\end{{game}}\n\\end{{{scale}}})");

    begin + &*end
}
pub fn generate_extensive(game: Game, scale: f32, py: Python) -> String {
    // seperate style from nodes
    // leave style detailes for users in latex
    // idealy choose level distance based on average player, or action name lengths
    let root_name = game.root.borrow(py).clone().children[0].borrow(py).clone().player.name.clone();
    let mut information_sets= HashMap::new().to_owned();
    let node_string = traverse_tree(game.root.borrow(py).clone(), 0, &mut information_sets, true, py);

    let begin = format!(r#"%%       Generated by stratpy       %%
% remember to include \usepackage{{tikz}}
% and \usetikzlibrary{{calc}}
\begin{{tikzpicture}}[scale={scale}]"#);

    let root = format!("\n% The Tree\n\\node(0)[solid,label=above:{{{root_name}}}]{{}}");
    let info_set = add_information_set(&mut information_sets);

    let end = format!("\n\\end{{tikzpicture}}");


    begin + style() + &*root + &*node_string + ";" + &*info_set + &*end
}

fn style() -> &'static str{
    // TODO: auto adjust distancing
    "\n
% Style for nodes
\\tikzstyle{solid}=[circle,draw,inner sep=1.2,fill=black]
\\tikzstyle{hollow}=[circle,draw,inner sep=1.2]\
\n% Spacing for every level of the tree
\\tikzstyle{level 1}=[level distance=10mm,sibling distance=35mm]
\\tikzstyle{level 2}=[level distance=15mm,sibling distance=15mm]"
}

//Traverses tree adding nodes to string and the ids of nodes sharing
// information set to the information_set Vec.

// creating a list style iterative recursive function to traverse the tree
fn traverse_tree(node: Decision, i:usize, information_set: &mut HashMap<SetKey,Vec<usize>>, is_root: bool, py: Python) -> String {
    let dir = if i == 0 {"left"} else {"right"};
    let (node_id, edge_label) = (node.id, node.name);
    let (node_type, label) = match node.utility {
        Utility::Numeral(x) => {
            let utility = format!("({}, {})", x[0], x[1]);
            ("hollow", format!("label=below:{{${utility}$}}"))
        },
        Utility::Variable(x) => {
            let utility = format!("({}, {})", x[0].name, x[1].name);
            ("hollow", format!("label=below:{{${utility}$}}"))
        }
        _ => {
            if let Some(_) = node.information_set {
                if let Some(name) = node.label {
                    ("solid", format!("label=above {dir}:{{{name}}}"))
                } else {
                    ("solid", format!(""))
                }
            } else {
                let player_name = node.children[0].borrow(py).player.name.clone();
                ("solid", format!("label=above {dir}:{{{player_name}}}"))
            }

        }
    };
    // if the node is part of an information set, push that value to a hashmap, creating a vec,
    // if it doesn't already exist
    if let Some(set_id) = node.information_set {
        information_set.entry(
            SetKey(set_id, node.children[0].borrow(py).player.name.clone()))
            .or_insert(Vec::new()).push(node.id);
    }
    let mut child_s = String::new();
    for (i, child) in node.children.iter().enumerate(){
        child_s.push_str(&*traverse_tree(child.borrow(py).clone(), i, information_set, false, py))
    }
    if is_root {
        child_s
    } else {
        let node_s = format!(r#"child{{node({node_id})[{node_type}, {label}]{{}}
    {child_s}edge from parent node[{dir}]{{${edge_label}$}}}}"#);
        node_s
    }
}

// Add's information set to the exported latex with default style
fn add_information_set(information_set: &mut HashMap<SetKey,Vec<usize>>) -> String {
    if information_set.is_empty(){ return "".to_string() }
    let mut set_string = String::from("% information set\n");
    for key in information_set.keys() {
        let (_id, name) = (key.0, key.1.clone());
        if let Some(value) = information_set.get(key){
            let (node1, node2) = (value[0], value[1]);
            set_string.push_str(&*format!("\\draw[dashed,rounded corners=10]($({node1}) \
            + (-.1,.125)$)rectangle($({node2}) +(.1,-.125)$);\n\
            \\node at ($({node1})!.5!({node2})$) {{{name}}};"))
        }

    }
    set_string
}

fn scale_to_string(value: f32) -> String {
    match value {
        0.0..=0.2 => "tiny".to_string(),
        0.2..=0.4 => "scriptsize".to_string(),
        0.4..=0.6 => "footnotesize".to_string(),
        0.6..=0.8 => "small".to_string(),
        0.8..=1.0 => "normalsize".to_string(),
        1.0..=1.2 => "large".to_string(),
        1.2..=1.4 => "Large".to_string(),
        1.4..=1.6 => "LARGE".to_string(),
        1.6..=1.8 => "huge".to_string(),
        _ => "Huge".to_string(),
    }
}


#[cfg(test)]
mod tests {
    //use super::*;
    #[test]
    fn test_latex_string() {
        let mut vec = vec![vec![1, 2], vec![3, 4]];
        println!("{}", vec[1][1])
    }
    #[test]
    fn test_normal(){
        let p2a = vec!["p2a[0]", "p2a[1]"];
        let p1a = vec!["p1a[0]", "p1a[1]"];
        let utility = vec![vec!["utility[0][0]", "utility[0][1]"], vec!["utility[1][0]", "utility[1][1]"]];

        let mut output = String::new();

        for (i, p2_item) in p2a.iter().enumerate() {
            if i > 0 {
                output += " & ";
            }
            output += &format!("{} ", p2_item);
        }
        output += "\\\\";

        for (i, p1_item) in p1a.iter().enumerate() {
            output += &format!("\n{} ", p1_item);

            for (j, utility_row) in utility.iter().enumerate() {
                if j > 0 {
                    output += " & ";
                }
                for (k, utility_item) in utility_row.iter().enumerate() {
                    if k > 0 {
                        output += " & ";
                    }
                    output += utility_item;
                }
            }

            output += "\\\\";
        }

        println!("{}", output);
    }

}

